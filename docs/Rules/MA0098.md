# MA0098 - Use indexer instead of LINQ methods

When working with collections that support indexing (such as arrays, `List<T>`, `IList<T>`, or `IReadOnlyList<T>`), using the indexer syntax `[index]` is more efficient than LINQ methods like `ElementAt()`, `First()`, and `Last()`. This rule suggests replacing these LINQ methods with direct indexer access for better performance.

The indexer approach provides direct access to elements without the overhead of LINQ extension methods and enumeration, resulting in faster execution and reduced memory allocations.

## Examples

### ElementAt() method

````csharp
// Non-compliant - using ElementAt()
var array = new int[10];
var list = new List<int>();

var value1 = array.ElementAt(5);        // ❌ Inefficient
var value2 = list.ElementAt(3);         // ❌ Inefficient

// Compliant - using indexer
var value3 = array[5];                  // ✅ Direct access
var value4 = list[3];                   // ✅ Direct access
````

### First() method

````csharp
// Non-compliant - using First() without predicate
var array = new int[10];
var list = new List<int>();

var first1 = array.First();             // ❌ Inefficient
var first2 = list.First();              // ❌ Inefficient

// Compliant - using indexer
var first3 = array[0];                  // ✅ Direct access
var first4 = list[0];                   // ✅ Direct access

// Note: First(predicate) is not affected by this rule
var firstEven = array.First(x => x % 2 == 0);  // ✅ Uses predicate, rule doesn't apply
````

### Last() method

````csharp
// Non-compliant - using Last() without predicate
var array = new int[10];
var list = new List<int>();

var last1 = array.Last();               // ❌ Inefficient
var last2 = list.Last();                // ❌ Inefficient

// Compliant - using indexer
var last3 = array[array.Length - 1];    // ✅ Direct access
var last4 = list[list.Count - 1];       // ✅ Direct access

// Note: Last(predicate) is not affected by this rule
var lastEven = array.Last(x => x % 2 == 0);    // ✅ Uses predicate, rule doesn't apply
````

## C# 8+ Index and Range Support

Starting with C# 8.0 and when targeting frameworks that support the Index and Range feature (.NET Core 3.0+, .NET 5+), the analyzer can suggest using the hat operator (`^`) for accessing elements from the end:

````csharp
// C# 8+ with compatible target framework
var array = new int[10];

// The analyzer suggests using the hat operator for Last()
var last = array[^1];                   // ✅ Equivalent to array[array.Length - 1]

// For older language versions or target frameworks, it uses the traditional syntax
var last = array[array.Length - 1];     // ✅ Fallback for older versions
````

## Performance Benefits

Using indexer access instead of LINQ methods provides several performance advantages:

- **Direct Access**: Indexers provide O(1) direct access to elements, while LINQ methods may involve enumeration overhead
- **No Extension Method Overhead**: Eliminates the cost of extension method calls and delegate invocations
- **Reduced Memory Allocations**: Avoids temporary objects and iterator allocations that LINQ methods might create
- **Better JIT Optimization**: The JIT compiler can better optimize simple indexer access compared to generic extension methods

## When This Rule Doesn't Apply

This rule has specific limitations and won't trigger in certain scenarios:

### Methods with Predicates

The rule only applies to parameterless versions of `First()` and `Last()`, and single-parameter `ElementAt()`. It doesn't apply when using predicates:

````csharp
// These are NOT flagged by the rule - predicates are necessary
var firstEven = list.First(x => x % 2 == 0);
var lastNegative = array.Last(x => x < 0);
````

### OrDefault Variants

The rule doesn't apply to the "OrDefault" variants of these methods:

````csharp
// These are NOT flagged by the rule
var item1 = list.FirstOrDefault();      // ✅ Rule doesn't apply
var item2 = list.LastOrDefault();       // ✅ Rule doesn't apply
var item3 = list.ElementAtOrDefault(5); // ✅ Rule doesn't apply
````

### Unsupported Collection Types

The rule only applies to collections that implement `IList<T>` or `IReadOnlyList<T>`:

````csharp
// These are NOT flagged by the rule - no indexer support
IEnumerable<int> enumerable = GetNumbers();
var first = enumerable.First();         // ✅ Rule doesn't apply

HashSet<int> hashSet = new();
var firstFromSet = hashSet.First();     // ✅ Rule doesn't apply
````

## Related Rules

This rule is part of a comprehensive suite of LINQ optimization rules in Meziantou.Analyzer:

- **[MA0020](MA0020.md)**: Use direct methods instead of LINQ methods - Suggests using `List<T>.Find()` instead of `FirstOrDefault()`, `List<T>.Exists()` instead of `Any()`, etc.
- **[MA0029](MA0029.md)**: Optimize LINQ usage by combining methods - Combines `Where()` with subsequent methods like `First()`, `Any()`, `Count()`
- **[MA0030](MA0030.md)**: Remove duplicate OrderBy methods - Removes redundant `OrderBy` calls
- **[MA0031](MA0031.md)**: Optimize Count usage - Replaces `Count() > 0` with `Any()`, `Count() == 0` with `!Any()`, etc.
- **[MA0063](MA0063.md)**: Use Where before OrderBy - Moves filtering before sorting for better performance
- **[MA0078](MA0078.md)**: Use Cast instead of Select for type conversion
- **[MA0112](MA0112.md)**: Use Count instead of Any for collections with a Count property
- **[MA0159](MA0159.md)**: Use Order instead of OrderBy when no key selector is needed

These rules work together to help optimize LINQ performance throughout your codebase.
